<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gyro-testing</title>
    <style>
        html, body {
            margin: 0;
        }
    </style>
</head>
<body>
    <canvas></canvas>
</body>
<script src="/socket.io/socket.io.js"></script>
<script>
    const domain = (new URL(window.location.href));
    const range = document.getElementById("myRange")
    
    const socketE = io(domain.origin);
    const socketR = io(domain.origin);
    
    socketE.on("connect", () => {
        socketE.emit("purpose", "mock-emitter")
    })
    socketR.on("connect", () => {
        socketR.emit("purpose", "mock-reciver")
    })
</script>
<script>
    const canvas = document.querySelector("canvas")
    canvas.width = 500
    canvas.height = 400
    const c = canvas.getContext('2d')
    let control = false;
    let mousePos = {};

    canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePos = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    })

    
</script>
<script>
    class Axis {
        constructor(x, y, r, name){
            this.name = name;
            this.pos = {x, y}
            this.radius = r;
            this.angle = Math.PI;
            this.fColor = "black";
            this.mouseRel = {}
            this.cRel = {
                x: Math.cos(this.angle) * this.radius + this.pos.x,
                y: Math.sin(this.angle) * this.radius + this.pos.y
            };
            this.active = false;
        }

        updateValueByMouse = () => {
            if(this.active){
                this.mouseRel.x = mousePos.x - this.pos.x
                this.mouseRel.y = mousePos.y - this.pos.y
    
                if(this.mouseRel.x >= 0) {
                    this.angle = Math.atan((this.mouseRel.y / this.mouseRel.x))
                } else {
                    this.angle = Math.atan((this.mouseRel.y / this.mouseRel.x)) + Math.PI
                }
            }

            this.draw()
        }

        updateValue( value ) {
            this.angle = value;
            this.draw()
        }

        draw () {
            this.cRel.x = Math.cos(this.angle) * this.radius + this.pos.x 
            this.cRel.y = Math.sin(this.angle) * this.radius + this.pos.y

            c.font = '10px Arial'
            c.fillStyle = this.fColor;

            c.fillText(this.name+ ": "+ this.angle, this.pos.x - this.radius, this.pos.y - this.radius - 20)
            c.beginPath()
            c.ellipse(this.pos.x, this.pos.y, this.radius, this.radius, 0, 0, 2 * Math.PI)
            c.stroke()
            c.beginPath()
            c.moveTo(this.pos.x, this.pos.y)
            c.lineTo(this.cRel.x, this.cRel.y)
            c.stroke()
            
            // c.strokeText(this.angle * 180/Math.PI, this.pos.x - this.radius, this.pos.y - this.radius*1.1)
            // c.strokeText(JSON.stringify(this.mouseRel), this.pos.x - this.radius, this.pos.y - this.radius*1.4)
        }

        clicked({ x, y }) {
            if(
                x > this.pos.x - this.radius &&
                x < this.pos.x + this.radius &&
                y > this.pos.y - this.radius &&
                y < this.pos.y + this.radius
            ){
                if(!this.active){
                    this.active = true;
                    let listener = () => {
                        this.active = false;
                        canvas.removeEventListener("click", listener)
                    }
                    canvas.addEventListener("click", listener)   
                }
            }
        }
    }

    class Gyroscope {
        constructor (x, y, r) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.values = {
                "X": new Axis(x, y, r, "X"),
                "Y": new Axis(x+150, y, r, "Y"),
                "Z": new Axis(x+300, y, r, "Z")
            }
        }

        updateByMouse () {
            Object.values(this.values).forEach(axis => axis.updateValueByMouse())
        }

        updateValue( data ) {
            Object.values(data).forEach( value => {
                this.values[value.axis].updateValue(value.angle)
            })
        }

        getAngles() {
            return Object.entries(this.values).map(([key, value]) => {
                return {axis: key, angle: value.angle}
            })
        }
    }
</script>
<script>
    //EMITTER SHOULD ONLY EMIT DIFFERENCE BETWEEN 
    //CURRENT AND PREV POS INSTEAD OF VALUE
    // TRANSMIT GYRO (ACCELERATION) => SERVER => TURRET

    //OUTPUT SHOULD BE ACCELERATION
    //INPUT IS POSITION
    const emitter = new Gyroscope(100, 100, 60)
    const receiver = new Gyroscope(100, 300, 60)

    canvas.addEventListener("click", () => {
        Object.values(emitter.values).forEach((axis) => {
            axis.clicked( mousePos )
        })
    })

    socketR.on("turret-command", (data) => receiver.updateValue(data))

    const animate = () => {
        window.requestAnimationFrame(animate)
        c.fillStyle = "#b5b3b3"
        c.fillRect(0, 0, canvas.width, canvas.height)
        
        emitter.updateByMouse()
        const noiceAngles = emitter.getAngles().map(val => {
            return {axis: val.axis, angle: val.angle - Math.random() * 0.1}
        })
        socketE.emit('gyro-data', noiceAngles)
        receiver.updateByMouse()
    }
    animate();
</script>
</html>