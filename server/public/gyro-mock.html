<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gyro-testing</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap');
        html, body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
        }
    </style>
</head>
<body>
    <canvas></canvas>
    <div>
        <button id="test">test</button>
        <input type="checkbox" id="emitter-switch" name="emitter">
        <label for="emitter">EMITTER</label>
        <input type="checkbox" id="reciever-switch" name="reciever" value="reciever">
        <label for="reciever">RECIEVER</label>

    </div>
</body>
<script src="/socket.io/socket.io.js"></script>
<script>
    let emitter = {}
    let receiver = {}
    const emitterSwitch = document.getElementById("emitter-switch")
    const recieverSwitch = document.getElementById("reciever-switch")

    const domain = (new URL(window.location.href));
    const range = document.getElementById("myRange")
    
    const socketE = io(domain.origin, { autoConnect: false });
    const socketR = io(domain.origin, { autoConnect: false });
    
    socketE.on("connect", () => {
        socketE.emit("purpose", "mock-emitter")
    })
    socketR.on("connect", () => {
        socketR.emit("purpose", "mock-reciver")
    })

    socketR.on("turret-log", (gyro) => console.log(gyro))
</script>
<script>
    const canvas = document.querySelector("canvas")
    canvas.width = 500
    canvas.height = 400
    const c = canvas.getContext('2d')
    let control = false;
    let mousePos = {};

    canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        mousePos = {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    })

    
</script>
<script>
    class Axis {
        constructor(x, y, r, name){
            this.name = name;
            this.pos = {x, y}
            this.radius = r;
            this.angle = Math.PI;
            this.fColor = "black";
            this.mouseRel = {}
            this.cRel = {
                x: Math.cos(this.angle) * this.radius + this.pos.x,
                y: Math.sin(this.angle) * this.radius + this.pos.y
            };
            this.active = false;
        }

        updateValueByMouse = () => {
            if(this.active){
                this.mouseRel.x = mousePos.x - this.pos.x
                this.mouseRel.y = mousePos.y - this.pos.y
    
                if(this.mouseRel.x >= 0) {
                    this.angle = Math.atan((this.mouseRel.y / this.mouseRel.x))
                } else {
                    this.angle = Math.atan((this.mouseRel.y / this.mouseRel.x)) + Math.PI
                }
            }

            this.draw()
        }

        updateValue( value ) {
            if(value) this.angle = value;
            this.draw()
        }

        draw () {
            this.cRel.x = Math.cos(this.angle) * this.radius + this.pos.x 
            this.cRel.y = Math.sin(this.angle) * this.radius + this.pos.y

            c.font = '10px Arial'
            c.fillStyle = this.fColor;

            c.fillText(this.name+ ": "+ this.angle, this.pos.x - this.radius, this.pos.y - this.radius - 20)
            c.beginPath()
            c.ellipse(this.pos.x, this.pos.y, this.radius, this.radius, 0, 0, 2 * Math.PI)
            c.stroke()
            c.beginPath()
            c.moveTo(this.pos.x, this.pos.y)
            c.lineTo(this.cRel.x, this.cRel.y)
            c.stroke()
            
            // c.strokeText(this.angle * 180/Math.PI, this.pos.x - this.radius, this.pos.y - this.radius*1.1)
            // c.strokeText(JSON.stringify(this.mouseRel), this.pos.x - this.radius, this.pos.y - this.radius*1.4)
        }

        clicked({ x, y }) {
            if(
                x > this.pos.x - this.radius &&
                x < this.pos.x + this.radius &&
                y > this.pos.y - this.radius &&
                y < this.pos.y + this.radius
            ){
                if(!this.active){
                    this.active = true;
                    let listener = () => {
                        this.active = false;
                        canvas.removeEventListener("click", listener)
                    }
                    canvas.addEventListener("click", listener)   
                }
            }
        }
    }

    class Gyroscope {
        constructor (x, y, r) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.axis = {
                "x": new Axis(x, y, r, "x"),
                "y": new Axis(x+150, y, r, "y"),
                "z": new Axis(x+300, y, r, "z")
            }

            this.sampleMode = true

            this.sampleRate = 100;
            this.transmisionRate = 100;
            this.sampleTrigger = 100; 

            this.prevAngle = this.getAngles()
            this.displacement = {}
            this.velocity = {}
            this.emitter = null;
            this.noiceScale = 0.0001;

            setInterval(()=>{
                const newAngles = this.getAngles()

                this.displacement = {
                    x: (newAngles.x - this.prevAngle.x),
                    y: (newAngles.y - this.prevAngle.y),
                    z: (newAngles.z - this.prevAngle.z)
                }

                this.velocity = {
                    x: this.displacement.x / this.sampleRate + this.getNoice(),
                    y: this.displacement.y / this.sampleRate + this.getNoice(),
                    z: this.displacement.z / this.sampleRate + this.getNoice()
                }
                this.prevAngle = {...newAngles}
            }, this.sampleRate)
        }

        getNoice () {
            return Math.sin(Math.random() * (Math.PI * 2)) * this.noiceScale
        }

        emitVelocity () {
            if(this.emitter != null) clearInterval(this.emitter)
            let iteration = 0;

            this.emitter = setInterval(() => {
                //SLOW EMITION RATE / SAMPLE RATE?
                if(this.sampleMode){
                    socketE.emit('gyro-data', this.getFormatedVelocity())
                    
                    if(iteration <= this.sampleTrigger) {
                        iteration ++
                        // console.log(iteration)
                    } else {
                        this.sampleMode = false
                        socketE.emit('gyro-sample-trigger')
                    }
                } else {
                    socketE.emit('gyro-data', this.getFormatedVelocity())
                    //THIS SERVES NO PUPOSE AFTER DONE, DO BETTER
                }

            }, this.transmisionRate)
        }

        getFormatedVelocity () {
            return `${this.velocity.x} ${this.velocity.y} ${this.velocity.z}`
        }

        getVelocity() {
            return this.velocity
        }

        setSampleRate (value) {
            //TODO: 
            //SET SAMPLE RATE DINAMICALLY
            this.sampleRate = value;
        }

        setTransmitionRate (value) {
            this.transmisionRate = value;
        }

        updateByMouse () {
            Object.values(this.axis).forEach(axis => axis.updateValueByMouse())
        }

        updateValue( data ) {
            Object.values(data).forEach( value => {
                this.axis[value.axis].draw()
            })
        }

        getAngles() {
            return {
                x: this.axis.x.angle, 
                y: this.axis.y.angle,
                z: this.axis.z.angle
            }
        }
    }
    class Turret {
        constructor (x, y, r) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.axis = {
                "x": new Axis(x, y, r, "x"),
                "y": new Axis(x+150, y, r, "y"),
                "z": new Axis(x+300, y, r, "z")
            }
        }

        updateValue( data ) {
            if(data){
                Object.entries(data).forEach(([key, value])=> {
                    this.axis[key].updateValue(value)
                })
            } else {
                Object.values(this.axis).forEach( value => {
                    value.updateValue()
                })
            }
        }
    }

</script>
<script>
   
    //EMITTER SHOULD ONLY EMIT DIFFERENCE BETWEEN 
    //CURRENT AND PREV POS INSTEAD OF VALUE
    // TRANSMIT GYRO (ACCELERATION) => SERVER => TURRET

    //OUTPUT SHOULD BE ACCELERATION
    //INPUT IS POSITION
    emitterSwitch.onchange = () => {
        if(emitterSwitch.checked) {
            emitter = new Gyroscope(100, 100, 60)
            socketE.connect()
            emitter.emitVelocity()
        }
        else {
            socketE.disconnect()
            emitter = {}
        } 
    }

    recieverSwitch.onchange = () => {
        if(recieverSwitch.checked) {
            receiver = new Turret(100, 300, 60)
            socketR.connect()
        }
        else {
            socketR.disconnect()
            receiver = {}
        }
    }


    document.getElementById("test").onclick = () => receiver.updateValue()

    canvas.addEventListener("click", () => {
        Object.values(emitter.axis).forEach((axis) => {
            axis.clicked( mousePos )
        })
    })

    socketR.on("turret-command", (data) => {
        // console.log(data)
        receiver.updateValue(data)
    })

    const animate = () => {
        window.requestAnimationFrame(animate)
        c.fillStyle = "#b5b3b3"
        c.fillRect(0, 0, canvas.width, canvas.height)

        if(emitterSwitch.checked) emitter.updateByMouse()
        if(recieverSwitch.checked) receiver.updateValue()
    }
    animate();
</script>
</html>